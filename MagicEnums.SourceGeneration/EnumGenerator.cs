using System.Diagnostics;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Concurrent;
using CodeChops.MagicEnums.SourceGeneration.Extensions;
using System.Linq.Expressions;
using System.Data.Common;

namespace CodeChops.MagicEnums.SourceGeneration;

[Generator]
public class EnumGenerator : ISourceGenerator
{
	public const string AttributeNamespace = "CodeChops.MagicEnums.Attributes";
	public const string AttributeName = "DiscoverableEnumMembersAttribute";

	public ConcurrentDictionary<string, Enum> EnumDataByNames { get; } = new();
	public ConcurrentDictionary<string, EnumDeclaration> EnumDeclarationByNames { get; } = new();
	public StringBuilder Errors { get; } = new();

	public void Execute(GeneratorExecutionContext context)
	{
		try
		{
			foreach (var declarationByName in this.EnumDeclarationByNames)
			{
				var enumCode = this.CreateEnum(declarationByName.Value);

				context.AddSource($"{declarationByName.Key}.g.cs", SourceText.From(enumCode, Encoding.UTF8));
			}
		}
#pragma warning disable CS0168 // Variable is declared but never used
#pragma warning disable IDE0059 // Unnecessary assignment of a value
		catch (Exception e)
#pragma warning restore IDE0059 // Unnecessary assignment of a value
#pragma warning restore CS0168 // Variable is declared but never used
		{
			Debugger.Launch();
		}
	}

	public string CreateEnum(EnumDeclaration declaration)
	{
		var code = new StringBuilder();

		this.EnumDataByNames.TryGetValue(declaration.EnumName, out var memberData);

		var members = memberData?.MemberByKeys
			.OrderByDescending(memberByKey => memberByKey.Key.FilePath == declaration.FilePath)
			.ThenBy(memberByKey => memberByKey.Key)
			.Select(memberByKey => memberByKey.Value)
			.GroupBy(member => member.Name)
			.Select(membersByName => membersByName.First())
			.ToArray() ?? Array.Empty<EnumMember>();

		var longestMemberNameLength = members
			.Select(member => member.Name)			
			.OrderByDescending(name => name.Length)
			.FirstOrDefault()?.Length ?? 0;

		code.Append(
$@"// <auto-generated />
using System;
using CodeChops.MagicEnums;
using {declaration.ValueType.ContainingNamespace};

{GetNamespaceDeclaration()}

#nullable enable

{GetComments()}
// {declaration.FilePath}
public partial record {declaration.EnumName}
{{	
	{GetMemberCode()}

	public static {declaration.EnumName} GenerateMember(string name, {declaration.ValueType.Name}? value = null, string? comment = null) => GetSingleMember(name);
}}

#nullable restore");

		return code.ToString();


		string? GetNamespaceDeclaration()
		{
			if (declaration.Namespace is null) return null;

			var code = $@"
namespace {declaration.Namespace};";

			return code;
		}


		StringBuilder GetComments()
		{
			var code = new StringBuilder();
			if (members.Length == 0) return code;

			code.Append($@"
/// <summary>
/// <code>");

			foreach (var member in members)
			{
				var outlineSpaces = new String(' ', longestMemberNameLength - member.Name.Length);

				code.Append($@"
/// -{member.Name}{outlineSpaces} = {(member.Value is null ? "(?)" : member.Value)}");
			}

			code.Append($@"
/// </code>
/// </summary>");

			return code;
		}


		StringBuilder GetMemberCode()
		{
			var code = new StringBuilder();

			foreach (var member in members)
			{
				if (member.Value is not null)
				{
					code.Append($@"
	/// <summary>
	/// (value: {member.Value})");

					if (member.Comment is not null)
					{
						code.Append($@"
	/// {member.Comment}");
					}
					code.Append($@"
	/// </summary>");
				}

				var outlineSpaces = new String(' ', longestMemberNameLength - member.Name.Length);
				code.Append(@$"
	public static {declaration.EnumName} {member.Name} {{ get; }} {outlineSpaces}= CreateMember({member.Value});
");
			}

			return code;
		}
	}

	public void Initialize(GeneratorInitializationContext context)
	{
		context.RegisterForSyntaxNotifications(() => new MySyntaxReceiver(this));
	}
}

public record Enum
{
	public ConcurrentDictionary<(string FilePath, LinePosition LinePosition), EnumMember> MemberByKeys { get; } = new();

	public Enum(string filePath, LinePosition linePosition, EnumMember member)
	{
		this.MemberByKeys.TryAdd((filePath, linePosition), member);
	}
}

public record EnumMember
{
	public string Name { get; }
	public string? Value { get; }
	public string? Comment { get; }

	public EnumMember(string name, string? value, string? comment)
	{
		this.Name = name ?? throw new ArgumentNullException(nameof(name));
		this.Value = String.IsNullOrWhiteSpace(value) ? null : value;
		this.Comment = String.IsNullOrWhiteSpace(comment) ? null : comment;
	}
}

public record EnumDeclaration
{
	public string EnumName { get; }
	public string? Namespace { get; }
	public ITypeSymbol ValueType { get; }
	public bool IsStringEnum { get; }
	public bool ImplicitDiscoverability { get; }
	public string FilePath { get; }

	public EnumDeclaration(INamedTypeSymbol type, ITypeSymbol valueType, bool implicitDiscoverability, string filePath)
	{
		if (type is null) throw new ArgumentNullException(nameof(type));
		if (valueType is null) throw new ArgumentNullException(nameof(valueType));

		this.EnumName = type.Name;
		var @namespace = type.ContainingNamespace?.ToString();
		this.Namespace = String.IsNullOrWhiteSpace(@namespace) ? null : @namespace;
		this.ValueType = valueType;
		this.IsStringEnum = valueType.Name.Equals(nameof(String), StringComparison.OrdinalIgnoreCase);
		this.ImplicitDiscoverability = implicitDiscoverability;
		this.FilePath = filePath;
	}
}

public class MySyntaxReceiver : ISyntaxContextReceiver
{
	private EnumGenerator Generator { get; }

	public MySyntaxReceiver(EnumGenerator generator)
	{
		this.Generator = generator;
	}

	public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
	{
		try
		{
			if (context.Node is TypeDeclarationSyntax typeDeclarationSyntax)
			{
				var type = context.SemanticModel.GetDeclaredSymbol(typeDeclarationSyntax);

				if (type is null || type.IsStatic || !type.IsRecord || !typeDeclarationSyntax.Modifiers.Any(m => m.ValueText == "partial")) return;
				if (!type.HasAttribute(EnumGenerator.AttributeName, EnumGenerator.AttributeNamespace, out var attribute)) return;

				if (!type.IsOrImplementsInterface(type => type.IsType("IMagicEnum", "CodeChops.MagicEnums.Core", isGenericType: true), out var interf))
				{
					return;
				}

				if (!interf.IsGeneric(typeParameterCount: 1, out var genericTypeArgument)) return;

				var implicitDiscoverability = attribute?.ConstructorArguments.FirstOrDefault().Value is true;

				var filePath = typeDeclarationSyntax.SyntaxTree.FilePath;
				var data = new EnumDeclaration(type, valueType: genericTypeArgument.Single(), implicitDiscoverability, filePath);
				this.Generator.EnumDeclarationByNames.TryAdd(type.Name, data);
			}
			else if (context.Node is InvocationExpressionSyntax invocation)
			{
				var argumentCount = invocation.ArgumentList.Arguments.Count;
				if (argumentCount == 0 || argumentCount > 3) return;

				if (invocation.ChildNodes().FirstOrDefault() is not MemberAccessExpressionSyntax memberAccess) return;
				if (memberAccess.Name.Identifier.ValueText != "GenerateMember") return;

				var nameParameter = invocation.ArgumentList.Arguments[0].Expression;

				//Debugger.Launch();

				if (nameParameter is not LiteralExpressionSyntax enumNameLiteral) return;
				var memberName = enumNameLiteral.Token.ValueText;

				string? memberValue = null;
				if (argumentCount >= 2)
				{
					if (invocation.ArgumentList.Arguments[1].Expression is not LiteralExpressionSyntax memberValueLiteral) return;
					memberValue = memberValueLiteral.Token.ValueText;
				}

				string? memberComment = null;
				if (argumentCount == 3)
				{
					if (invocation.ArgumentList.Arguments[2].Expression is not LiteralExpressionSyntax commentLiteral) return;
					memberComment = commentLiteral?.Token.ValueText;
				}

				AddMember(memberAccess, memberName, memberValue, memberComment, requiresImplicitDiscoverability: false);
			}
			else if (context.Node is MemberAccessExpressionSyntax memberAccess && memberAccess.Parent is not InvocationExpressionSyntax)
			{
				var memberName = memberAccess.Name.Identifier.ValueText;
				AddMember(memberAccess, memberName, memberValue: null, memberComment: null, requiresImplicitDiscoverability: true);
			}
		}
#pragma warning disable CS0168 // Variable is declared but never used
		catch (Exception e)
#pragma warning restore CS0168 // Variable is declared but never used
		{
			Debugger.Launch();
		}

		void AddMember(MemberAccessExpressionSyntax memberAccess, string memberName, string? memberValue, string? memberComment, bool requiresImplicitDiscoverability)
		{
			if (memberAccess.Expression is not IdentifierNameSyntax identifierName) return;
			var enumName = identifierName.Identifier.ValueText;

			if (!this.Generator.EnumDeclarationByNames.TryGetValue(enumName, out var declaration)) return;
			if (!declaration.ImplicitDiscoverability && requiresImplicitDiscoverability) return;

			var mappedLineSpan = memberAccess.SyntaxTree.GetLineSpan(memberAccess.Span);

			var member = new EnumMember(memberName.Trim('"'), memberValue, memberComment?.Trim('"'));
			if (!this.Generator.EnumDataByNames.TryGetValue(enumName, out var enumData))
			{
				var data = new Enum(memberAccess.SyntaxTree.FilePath, mappedLineSpan.StartLinePosition, member);
				this.Generator.EnumDataByNames.TryAdd(enumName, data);
			}
			else
			{
				var key = (memberAccess.SyntaxTree.FilePath, mappedLineSpan.StartLinePosition);
				enumData.MemberByKeys.TryRemove(key, out _);
				enumData.MemberByKeys.TryAdd(key, member);
			}
		}
	}
}