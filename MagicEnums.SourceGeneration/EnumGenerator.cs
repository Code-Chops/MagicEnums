using System.Diagnostics;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Concurrent;
using CodeChops.MagicEnums.SourceGeneration.Extensions;

namespace CodeChops.MagicEnums.SourceGeneration;

[Generator]
public class EnumGenerator : ISourceGenerator
{
	public const string AttributeNamespace = "CodeChops.MagicEnums.Attributes";
	public const string AttributeName = "DiscoverableEnumMembersAttribute";

	public ConcurrentDictionary<string, Enum> EnumDataByNames { get; } = new();
	public ConcurrentDictionary<string, EnumDeclaration> EnumDeclarationByNames { get; } = new();
	public StringBuilder Errors { get; } = new();

	public void Execute(GeneratorExecutionContext context)
	{
		try
		{
			foreach (var declarationByName in this.EnumDeclarationByNames)
			{
				var enumCode = this.CreateEnum(declarationByName.Value);

				context.AddSource($"{declarationByName.Key}.g.cs", SourceText.From(enumCode, Encoding.UTF8));
			}
		}
#pragma warning disable CS0168 // Variable is declared but never used
#pragma warning disable IDE0059 // Unnecessary assignment of a value
		catch (Exception e)
#pragma warning restore IDE0059 // Unnecessary assignment of a value
#pragma warning restore CS0168 // Variable is declared but never used
		{
			Debugger.Launch();
		}
	}

	public string CreateEnum(EnumDeclaration declaration)
	{
		var code = new StringBuilder();

		this.EnumDataByNames.TryGetValue(declaration.EnumName, out var memberData);

		var members = memberData?.MemberByKeys
			.OrderBy(memberByKey => memberByKey.Key)
			.Select(memberByKey => memberByKey.Value)
			.GroupBy(member => member.Name)
			.Select(membersByName => membersByName.First())
			.ToArray() ?? Array.Empty<EnumMember>();

		var longestMemberNameLength = members.Select(member => member.Name).OrderByDescending(name => name.Length).FirstOrDefault()?.Length ?? 0;

		code.Append(
$@"// <auto-generated />
using System;
using CodeChops.MagicEnums;
using {declaration.ValueType.ContainingNamespace};

{GetNamespaceDeclaration()}

#nullable enable

{GetComments()}
public partial record {declaration.EnumName}
{{	{GetMemberCode()}

	{GetExtensionMethod()}
}}

#nullable restore");

		return code.ToString();


		string? GetNamespaceDeclaration()
		{
			if (declaration.Namespace is null) return null;

			var code = $@"
namespace {declaration.Namespace};";

			return code;
		}


		StringBuilder GetComments()
		{
			var code = new StringBuilder();
			if (members.Length == 0) return code;

			code.Append($@"
/// <summary>
/// <code>");

			foreach (var member in members)
			{
				var outlineSpaces = new String(' ', longestMemberNameLength - member.Name.Length);

				code.Append($@"
/// -{member.Name}{outlineSpaces} = {(member.Value is null ? "(?)" : member.Value)}");
			}

			code.Append($@"
/// </code>
/// </summary>");

			return code;
		}


		StringBuilder GetMemberCode()
		{
			var code = new StringBuilder();

			foreach (var member in members)
			{
				if (member.Value is not null)
				{
					code.Append($@"
	/// <summary>
	/// (value: {member.Value})");

					if (member.Comment is not null)
					{
						code.Append($@"
	/// {member.Comment}");
					}
					code.Append($@"
	/// </summary>");
				}

				var outlineSpaces = new String(' ', longestMemberNameLength - member.Name.Length);
				code.Append(@$"
	public static {declaration.EnumName} {member.Name} {{ get; }} {outlineSpaces}= Create({member.Value});
");
			}

			return code;
		}


		string GetExtensionMethod()
		{
			return declaration.IsStringEnum
				? $@"
	public static {declaration.EnumName} CreateAndUse(string name, {declaration.ValueType.Name}? value = null, string? comment = null) => GetSingleMember(name);"
				: $@"
	public static {declaration.EnumName} CreateAndUse(string name, {declaration.ValueType.Name} value, string? comment = null) => GetSingleMember(name);";
		}
	}

	public void Initialize(GeneratorInitializationContext context)
	{
		context.RegisterForSyntaxNotifications(() => new MySyntaxReceiver(this));
	}
}

public record Enum
{
	public ConcurrentDictionary<(string FilePath, LinePosition LinePosition), EnumMember> MemberByKeys { get; } = new();

	public Enum(string filePath, LinePosition linePosition, EnumMember member)
	{
		this.MemberByKeys.TryAdd((filePath, linePosition), member);
	}
}

public record EnumMember
{
	public string Name { get; }
	public string? Value { get; }
	public string? Comment { get; }

	public EnumMember(string name, string? value, string? comment)
	{
		this.Name = name ?? throw new ArgumentNullException(nameof(name));
		this.Value = value;
		this.Comment = comment;
	}
}

public record EnumDeclaration
{
	public string EnumName { get; }
	public string? Namespace { get; }
	public ITypeSymbol ValueType { get; }
	public bool IsStringEnum { get; }

	public EnumDeclaration(INamedTypeSymbol type, ITypeSymbol valueType)
	{
		if (type is null) throw new ArgumentNullException(nameof(type));
		if (valueType is null) throw new ArgumentNullException(nameof(valueType));

		this.EnumName = type.Name;
		var @namespace = type.ContainingNamespace?.ToString();
		this.Namespace = String.IsNullOrWhiteSpace(@namespace) ? null : @namespace;
		this.ValueType = valueType;
		this.IsStringEnum = valueType.Name.Equals(nameof(String), StringComparison.OrdinalIgnoreCase);
	}
}

public class MySyntaxReceiver : ISyntaxContextReceiver
{
	private EnumGenerator Generator { get; }

	public MySyntaxReceiver(EnumGenerator generator)
	{
		this.Generator = generator;
	}

	public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
	{
		try
		{
			if (context.Node is TypeDeclarationSyntax typeDeclarationSyntax)
			{
				var type = context.SemanticModel.GetDeclaredSymbol(typeDeclarationSyntax);

				if (type is null || type.IsStatic || !type.IsRecord || !typeDeclarationSyntax.Modifiers.Any(m => m.ValueText == "partial")) return;
				if (!type.HasAttribute(EnumGenerator.AttributeName, EnumGenerator.AttributeNamespace, out var attribute)) return;

				//Debugger.Launch();
				if (!type.IsOrImplementsInterface(type => type.IsType("IMagicEnum", "CodeChops.MagicEnums.Core", isGenericType: true), out var interf))
				{
					return;
				}

				if (!interf.IsGeneric(1, out var genericTypeArgument)) return;

				var data = new EnumDeclaration(type, valueType: genericTypeArgument.Single());
				//Debugger.Launch();
				if (!this.Generator.EnumDeclarationByNames.ContainsKey(type.Name)) this.Generator.EnumDeclarationByNames.TryAdd(type.Name, data);
			}

			if (context.Node is InvocationExpressionSyntax expression)
			{
				var argumentCount = expression.ArgumentList.Arguments.Count;

				if (argumentCount < 1 || argumentCount > 3 || !expression.ToString().Contains("CreateAndUse")) return;

				var enumName = expression.ChildNodes().FirstOrDefault()?.ChildNodes().FirstOrDefault()?.ToString();
				if (enumName is null) return;

				var memberName = expression.ArgumentList.Arguments[0].ToString();
				var memberValue = expression.ArgumentList.Arguments.ElementAtOrDefault(1)?.ToString();
				var memberComment = expression.ArgumentList.Arguments.ElementAtOrDefault(2)?.ToString();

				var mappedLineSpan = expression.SyntaxTree.GetLineSpan(expression.Span);

				var member = new EnumMember(memberName.Trim('"'), memberValue, memberComment?.Trim('"'));
				if (!this.Generator.EnumDataByNames.TryGetValue(enumName, out var enumData))
				{
					var data = new Enum(expression.SyntaxTree.FilePath, mappedLineSpan.StartLinePosition, member);
					this.Generator.EnumDataByNames.TryAdd(enumName, data);
				}
				else
				{
					var key = (expression.SyntaxTree.FilePath, mappedLineSpan.StartLinePosition);
					enumData.MemberByKeys.TryRemove(key, out _);
					enumData.MemberByKeys.TryAdd(key, member);
				}
			}
		}
#pragma warning disable CS0168 // Variable is declared but never used
		catch (Exception e)
#pragma warning restore CS0168 // Variable is declared but never used
		{
			Debugger.Launch();
		}
	}
}