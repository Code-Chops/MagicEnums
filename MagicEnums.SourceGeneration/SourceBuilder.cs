using System.Text;
using Microsoft.CodeAnalysis;
using System.Collections.Concurrent;
using CodeChops.MagicEnums.SourceGeneration.Entities;
using Microsoft.CodeAnalysis.Text;
using CodeChops.MagicEnums.SourceGeneration.Extensions;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Immutable;
using System.Diagnostics;

namespace CodeChops.MagicEnums.SourceGeneration;

internal class SourceBuilder
{
	public const string GenerateMethodName	= "GenerateMember";
	public const string InterfaceName		= "IMagicEnum";
	public const string InterfaceNamespace	= "CodeChops.MagicEnums.Core";

	public static void CreateCode(SourceProductionContext context, ImmutableArray<EnumMember> members, Dictionary<string, EnumDefinition> enumDefinitionsByName)
	{
		//Debugger.Launch();
		if (members.IsDefaultOrEmpty) return;

		try
		{
			var membersByDefinitions = members
				.GroupBy(member => enumDefinitionsByName.TryGetValue(member.EnumName, out var definition) ? definition : null)
				.Where(grouping => grouping.Key is not null);
			
			foreach (var membersByDefinition in membersByDefinitions)
			{
				var declaration = membersByDefinition.Key!;
				var enumCode = CreateEnumCode(declaration, membersByDefinition); //TODO

				context.AddSource($"{declaration.Name}.g.cs", SourceText.From(enumCode, Encoding.UTF8));
			}
		}
		catch (Exception e)
		{
			context.ReportDiagnostic(
				id: "ESG1",
				title: "Unknown error",
				description: e.Message.ToString(),
				severity: DiagnosticSeverity.Error);
		}
	}

	private static string CreateEnumCode(EnumDefinition definition, IEnumerable<EnumMember> members)
	{
		var code = new StringBuilder();

		members = members
			.OrderByDescending(member => member.FilePath == definition.FilePath)
			.ThenBy(member => member.LinePosition)
			.GroupBy(member => member.Name)
			.Select(membersByName => membersByName.First());

		var longestMemberNameLength = members
			.Select(member => member.Name)
			.OrderByDescending(name => name.Length)
			.FirstOrDefault()?.Length ?? 0;

		code.Append(
$@"// <auto-generated />
#nullable enable
using System;
using CodeChops.MagicEnums;
{GetValueTypeUsing()}
{GetNamespaceDeclaration()}
{GetEnumRecord()}
{definition.AccessModifier}static class {definition.Name}Extensions
{{
	public static {definition.Name} {GenerateMethodName}(this {definition.Name} member, {definition.ValueTypeName}? value = null, string? comment = null) => member;
}}

#nullable restore");

		return code.ToString();


		string? GetValueTypeUsing()
		{
			var ns = definition.ValueTypeNamespace;
			if (ns == "System") return null;

			ns = $"using {ns};";
			return ns;
		}


		string? GetNamespaceDeclaration()
		{
			if (definition.Namespace is null) return null;

			var code = $@"namespace {definition.Namespace};";
			return code;
		}


		StringBuilder GetEnumRecord()
		{
			var code = new StringBuilder();

			if (!members.Any()) return code;

			code.Append($@"
/// <summary>
/// <code>");

			foreach (var member in members)
			{
				var outlineSpaces = new string(' ', longestMemberNameLength - member.Name.Length);

				code.Append($@"
/// -{member.Name}{outlineSpaces} = {(member.Value is null ? "(?)" : member.Value)}");
			}

			code.Append($@"
/// </code>
/// </summary>");

			code.Append($@"
{definition.AccessModifier}partial record {definition.Name}
{{	
");

			foreach (var member in members)
			{
				if (member.Value is not null)
				{
					code.Append($@"
	/// <summary>
	/// (value: {member.Value})");

					if (member.Comment is not null)
					{
						code.Append($@"
	/// {member.Comment}");
					}
					code.Append($@"
	/// </summary>");
				}

				var outlineSpaces = new string(' ', longestMemberNameLength - member.Name.Length);
				code.Append(@$"
	public static {definition.Name} {member.Name} {{ get; }} {outlineSpaces}= CreateMember({member.Value});
");
			}

			code.Append($@"
}}
");

			return code;
		}
	}
}