using System.Text;
using Microsoft.CodeAnalysis;
using CodeChops.MagicEnums.SourceGeneration.Entities;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;

namespace CodeChops.MagicEnums.SourceGeneration;

internal class SourceBuilder
{
	/// <summary>
	/// Creates a partial record of the enum definition which includes the discovered enum members. It also generates an extension class for the explicit enum definitions.
	/// </summary>
	public static void CreateSource(SourceProductionContext context, ImmutableArray<EnumMember> enumMembers, Dictionary<string, EnumDefinition> enumDefinitionsByName)
	{
		if (enumMembers.IsDefaultOrEmpty) return;
		if (enumDefinitionsByName.Count == 0) return;
		
		// Get the members and their definition.
		// Exclude the members that have no definition, or the members that are implicitly defined while their definition doesn't allow it.
		var definitionsAndMembers = enumMembers
			.GroupBy(member => enumDefinitionsByName.TryGetValue(member.EnumName, out var definition) ? definition : null)
			.Where(grouping => grouping.Key is not null)
			.Select(grouping => (Definition: grouping.Key, Members: grouping.Where(member => grouping.Key!.ImplicitDiscoverabilityIsEnabled || !member.IsImplicitlyDiscovered)));
			
		foreach (var (definition, members) in definitionsAndMembers)
		{
			if (!members.Any()) continue;

			var enumCode = CreateEnumSource(definition!, members);
			context.AddSource($"{definition!.Name}.g.cs", SourceText.From(enumCode, Encoding.UTF8));
		}
	}

	private static string CreateEnumSource(EnumDefinition definition, IEnumerable<EnumMember> members)
	{
		var code = new StringBuilder();

		// Place the members that are discovered in the enum definition file itself first. The order can be relevant because the value of enum members can be implicitily incremental.
		// Do a distinct on the file path and line position so the members will be deduplicated while typing their invocation.
		// Also do a distinct on the member name.
		members = members
			.OrderByDescending(member => member.FilePath == definition.FilePath)
			.GroupBy(member => (member.FilePath, member.LinePosition))
			.Select(group => group.First())
			.GroupBy(member => member.Name)
			.Select(membersByName => membersByName.First());

		// Is used for correct enum member outlining.
		var longestMemberNameLength = members
			.Select(member => member.Name)
			.OrderByDescending(name => name.Length)
			.FirstOrDefault()?.Length ?? 0;

		// Create the whole source.
		code.Append(
$@"// <auto-generated />
#nullable enable
using System;
using CodeChops.MagicEnums;
{GetValueTypeUsing()}
{GetNamespaceDeclaration()}
{GetEnumRecord()}
/// <summary>
/// Call this method in order to create discovered enum members while invoking them (on the fly). So enum members are automatically deleted when not being used.
/// </summary>
{definition.AccessModifier}static class {definition.Name}Extensions
{{
	public static {definition.Name} {SourceGenerator.GenerateMethodName}(this {definition.Name} member, {definition.ValueTypeName}? value = null, string? comment = null) => member;
}}

#nullable restore");

		return code.ToString();

		// Creates a using for the definition of the enum value type (or null if not applicable).
		string? GetValueTypeUsing()
		{
			var ns = definition.ValueTypeNamespace;
			if (ns == "System") return null;

			ns = $"using {ns};";
			return ns;
		}

		// Creates the namespace definition of the location of the enum definition (or null if the namespace is not defined).
		string? GetNamespaceDeclaration()
		{
			if (definition.Namespace is null) return null;

			var code = $@"namespace {definition.Namespace};";
			return code;
		}

		// Creates the partial enum record (or null if the enum has no members).
		string? GetEnumRecord()
		{
			if (!members.Any()) return null;
			
			var code = new StringBuilder();

			// Create the comments on the enum record.
			code.Append($@"
/// <summary>
/// <code>");

			foreach (var member in members)
			{
				var outlineSpaces = new String(' ', longestMemberNameLength - member.Name.Length);

				code.Append($@"
/// -{member.Name}{outlineSpaces} = {(member.Value is null ? "?" : member.Value)}");
			}

			code.Append($@"
/// </code>
/// </summary>");

			// Define the enum record.
			code.Append($@"
{definition.AccessModifier}partial record {definition.Name}
{{	
");

			// Add the discovered members to the enum record.
			foreach (var member in members)
			{
				// Create the comment on the enum member.
				if (member.Value is not null || member.Comment is not null)
				{
					code.Append($@"
	/// <summary>");

					if (member.Value is not null)
					{ 
						code.Append($@"
	/// <para>(value: {member.Value})</para>");
					}

					if (member.Comment is not null)
					{
						code.Append($@"
	/// {member.Comment}");
					}

				code.Append($@"
	/// </summary>");
				}				

				// Create the enum member itself.
				var outlineSpaces = new string(' ', longestMemberNameLength - member.Name.Length);
				code.Append(@$"
	public static {definition.Name} {member.Name} {{ get; }} {outlineSpaces}= CreateMember({member.Value});
");
			}

			code.Append($@"
}}
");

			return code.ToString();
		}
	}
}